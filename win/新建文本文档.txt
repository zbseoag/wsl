如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？

使用消息队列中间件时，都有可能会出现消息重复消费的问题，这很正常。
这个问题通常不是 MQ 自己保证的，是由我们开发来保证的。
在客户端消费消息的时候，都会有应答机制


sudo iptables -P FORWARD ACCEPT

任务管理器->服务->打开服务 -> Routing and Remote Access 
打开 powershell 管理员身份运行：
route add 172.17.0.0 mask 255.255.0.0 172.17.0.1


route add 172.17.0.0 mask 255.255.0.0 172.19.48.1


32 位
8 8 8 + 6
10.10.2.1

网络号 子网号 + 主机号
主机号不能全0（本网络）或全1(广播) 所以至少两位。

b类，网络号16位 子网号占8位，主机号也占8位

子网掩码：网络号全1，主机号全0
全1.全1.0.0 => 255.255.0.0

子网掩码与ip地址相与，得到子网网络地址

1.1.3.10
如果有8位子网号，则子网地址是： 1.1.3.0

ip: 141.14.72.24 子网掩码：255.255.192.0 求网络地址
解：141.14.X.0
70  = 01001000
192 = 11000000
-------------------
      01000000 = 64

主机的IP地址是202.112.14.137 掩码 255.255.255.224，求网络地址和广播地址

掩码 255.255.255.224 转二进制：

11111111 11111111 11111111 11100000
网络号有27位，主机号有5位

IP地址&子网掩码

11001010 01110000 00001110 10001001
11111111 11111111 11111111 11100000
------------------------------------------------------
11001010 01110000 00001110 10000000

即：202.112.14.128
广播地址：网络地址的主机位全部变成1 ，100 11111 即159 即：202.112.14.159

010011|00




核心使用场景有3个：解耦、异步、削峰。

解耦：A 系统需要调用 B C 两个系统的接口，现在如果 C 系统不要了，并新增加一个 E 系统，那么A系统就得修改代码。
而且 A 系统要时时刻刻考虑它所依赖的几个系统如果挂了该咋办？要不要重发，要不要把消息存起来，等一系列问题。

如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。
如果某个系统不需要数据了，就取消对 MQ 消息的消费即可。
这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。

总结：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。

技巧：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。
但是其实这个调用是不需要直接同步调用，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。

异步：同步请求是要等待整个系统流程处理完成之后才返回结果，如果涉及到多个外部系统调用，往往很慢。有此场景做成异步体验会更好，如：发送短信验证码。

削峰：一个系统只在某个时间段请求流量比较高，超出系统承载能力，但又没必要为了应对这一段时间的流量，而提升系统并发能力。
那么可以考虑用将所有请求先暂存到 MQ 中，再从 MQ 中拉取，这样保证系统不会挂掉，而且高峰期一过，积压的消息也会很解决掉。

缺点有以下几个：
系统可用性降低：引入 MQ 之后，MQ 成为多个系统之间通信的桥梁， MQ 一挂，整套系统就崩溃了。所以要保证消息队列的高可用。

系统复杂度提高：怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？

一致性问题：
A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；
但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。


所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，系统复杂度提升了一个数量级，也许是复杂了 10 倍。
但是关键时刻，用，还是得用的。




docker network create network
docker run -d --network network --name nginx-1 nginx:latest
docker run -d --network network --name nginx-2 nginx:latest
docker run -d --network network --name nginx-3 nginx:latest

docker exec -it nginx-1 bash
sed -i "s/deb.debian.org/mirrors.aliyun.com/g" /etc/apt/sources.list
apt update
apt install -y vim iputils-ping

vim /etc/nginx/nginx.conf

http {
     upstream backend {
     server nginx-2;
     server nginx-3;

   }

    server {     
      listen 80;
      location / {
      	proxy_pass http://backend;
			}
   }
}



echo 'nginx2' > /usr/share/nginx/html/index.html

echo 'nginx3' > /usr/share/nginx/html/index.html



docker.open nginx-1 /etc/nginx/nginx.conf
docker.open nginx-2 /usr/share/nginx/html/index.html
docker.open nginx-3 /usr/share/nginx/html/index.html


使用 self:: 或者 __CLASS__ 对当前类的静态引用，取决于当前方法所在的类
static  表示运行时最初调用的类来绕过限制