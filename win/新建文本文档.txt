如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？

使用消息队列中间件时，都有可能会出现消息重复消费的问题，这很正常。
这个问题通常不是 MQ 自己保证的，是由我们开发来保证的。
在客户端消费消息的时候，都会有应答机制


sudo iptables -P FORWARD ACCEPT

任务管理器->服务->打开服务 -> Routing and Remote Access 
打开 powershell 管理员身份运行：
route add 172.17.0.0 mask 255.255.0.0 172.17.0.1


route add 172.17.0.0 mask 255.255.0.0 172.19.48.1


32 位
8 8 8 + 6
10.10.2.1

网络号 子网号 + 主机号
主机号不能全0（本网络）或全1(广播) 所以至少两位。

b类，网络号16位 子网号占8位，主机号也占8位

子网掩码：网络号全1，主机号全0
全1.全1.0.0 => 255.255.0.0

子网掩码与ip地址相与，得到子网网络地址

1.1.3.10
如果有8位子网号，则子网地址是： 1.1.3.0

ip: 141.14.72.24 子网掩码：255.255.192.0 求网络地址
解：141.14.X.0
70  = 01001000
192 = 11000000
-------------------
      01000000 = 64

主机的IP地址是202.112.14.137 掩码 255.255.255.224，求网络地址和广播地址

掩码 255.255.255.224 转二进制：

11111111 11111111 11111111 11100000
网络号有27位，主机号有5位

IP地址&子网掩码

11001010 01110000 00001110 10001001
11111111 11111111 11111111 11100000
------------------------------------------------------
11001010 01110000 00001110 10000000

即：202.112.14.128
广播地址：网络地址的主机位全部变成1 ，100 11111 即159 即：202.112.14.159

010011|00




核心使用场景有3个：解耦、异步、削峰。

解耦：A 系统需要调用 B C 两个系统的接口，现在如果 C 系统不要了，并新增加一个 E 系统，那么A系统就得修改代码。
而且 A 系统要时时刻刻考虑它所依赖的几个系统如果挂了该咋办？要不要重发，要不要把消息存起来，等一系列问题。

如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。
如果某个系统不需要数据了，就取消对 MQ 消息的消费即可。
这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。

总结：通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。

技巧：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。
但是其实这个调用是不需要直接同步调用，如果用 MQ 给它异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个 MQ 去进行系统的解耦。

异步：同步请求是要等待整个系统流程处理完成之后才返回结果，如果涉及到多个外部系统调用，往往很慢。有此场景做成异步体验会更好，如：发送短信验证码。

削峰：一个系统只在某个时间段请求流量比较高，超出系统承载能力，但又没必要为了应对这一段时间的流量，而提升系统并发能力。
那么可以考虑用将所有请求先暂存到 MQ 中，再从 MQ 中拉取，这样保证系统不会挂掉，而且高峰期一过，积压的消息也会很解决掉。

缺点有以下几个：
系统可用性降低：引入 MQ 之后，MQ 成为多个系统之间通信的桥梁， MQ 一挂，整套系统就崩溃了。所以要保证消息队列的高可用。

系统复杂度提高：怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？

一致性问题：
A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；
但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。


所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，系统复杂度提升了一个数量级，也许是复杂了 10 倍。
但是关键时刻，用，还是得用的。


docker network create network
docker run -d --network network --name nginx-1 nginx:latest
docker run -d --network network --name nginx-2 nginx:latest
docker run -d --network network --name nginx-3 nginx:latest

docker exec -it nginx-1 bash
sed -i "s/deb.debian.org/mirrors.aliyun.com/g" /etc/apt/sources.list
apt update
apt install -y vim iputils-ping

vim /etc/nginx/nginx.conf

http {
     upstream backend {
     server nginx-2;
     server nginx-3;

   }

    server {     
      listen 80;
      location / {
      	proxy_pass http://backend;
			}
   }
}



echo 'nginx2' > /usr/share/nginx/html/index.html

echo 'nginx3' > /usr/share/nginx/html/index.html



docker.open nginx-1 /etc/nginx/nginx.conf
docker.open nginx-2 /usr/share/nginx/html/index.html
docker.open nginx-3 /usr/share/nginx/html/index.html


使用 self:: 或者 __CLASS__ 对当前类的静态引用，取决于当前方法所在的类
static  表示运行时最初调用的类来绕过限制




模式修饰符 
i 忽略大小写  
m 多行模式 
s 点号匹配包括换行符
x 
A (PCRE_ANCHORED) 锚定模式
S 分析
U 非贪婪


1、表达式定义常量：可以使用包括数值、字符串字面量以及其他常量在内的数值表达式来 定义常量、声明属性以及设置函数参数默认值。

使用 ... 运算符定义变长参数函数

使用 ... 运算符进行参数展开

使用 ** 进行幂运算

use function 以及 use const

PHP 的 SAPI 模块中实现了一个 交互式调试器，叫做 phpdbg

大文件上传：支持大于 2GB 的文件上传。

GMP 支持运算符重载：$a = gmp_init(42); $b = gmp_init(17); echo $a + $b；


使用 hash_equals() 比较字符串避免时序攻击。

在 PHP 7 中，很多致命错误以及可恢复的致命错误，都被转换为异常来处理了。

set_exception_handler() 不再保证收到的一定是 Exception 对象 
function handler(Throwable $e) { ... }


间接调用的表达式的新旧解析顺序，旧的从右向左，新的从左到右。如：$$foo['bar']['baz'] 	PHP5：${$foo['bar']['baz']}	 PHP7：($$foo)['bar']['baz']

foreach不再移动数组内部指针

foreach 通过值遍历时，操作的值为数组的副本，foreach 中的操作不会修改原数组的值。

foreach通过引用遍历时，能跟踪变化。

十六进制形式的字符串不再被认为是数字。

dl()在 PHP-FPM 不可用，在 CLI 和 embed SAPIs 中仍可用。


类/接口 名称	值必须为指定类和接口的实例化对象 instanceof	 
self	值必定是所在方法的类的一个 instanceof。 只能在类的内部使用。	 
array	值必须为 array。	 
callable	值必定是一个有效的 callable。 不能用于类属性的类型声明。	 
bool	值必须为一个布尔值。	 
float	值必须为一个浮点数字。	 
int	值必须为一个整型数字。	 
string	值必须为一个 string。	 
iterable	值必须为 array 或 instanceof Traversable。	PHP 7.1.0
object	值必须为object。	PHP 7.2.0
mixed	值可以为任何类型。	PHP 8.0.0

联合类型接受多个不同的类型做为参数。声明联合类型的语法为 T1|T2|...。联合类型自 PHP 8.0.0 起可用。

false 伪类型 通过联合类型支持字面类型（Literal Type）false， 出于历史原因，很多内部函数在失败时返回了 false 而不是 null。


null合并运算符 $username = $_GET['user'] ?? 'nobody';

标量类型声明

组合比较符
通过 define() 定义常量数组
new class 来实例化一个匿名类

Closure::call() 现在有着更好的性能，简短干练的暂时绑定一个方法到对象上闭包并调用它。
整数除法函数 intdiv() 

Throwable
Error
TypeError
ParseError
AssertionError
ArithmeticError
DivisionByZeroError

放宽了保留词限制，现在允许全局保留词用于类/接口/Trait 中的属性、常量和方法名。 唯一的限制是： class关键词不能用于常量名，否则会和类名解析语法冲突 (ClassName::class)。




可为空（Nullable）类型 
function testReturn(): ?string

void 返回值类型
短数组语法
类常量可见性
iterable 伪类型
多异常捕获处理 FirstException | SecondException $e

list()现在支持键名
$data = [
    ["id" => 1, "name" => 'Tom'],
    ["id" => 2, "name" => 'Fred'],
];

// list() style
list("id" => $id1, "name" => $name1) = $data[0];

// [] style
["id" => $id1, "name" => $name1] = $data[0];

// list() style
foreach ($data as list("id" => $id, "name" => $name)) {
    // logic here with $id and $name
}

// [] style
foreach ($data as ["id" => $id, "name" => $name]) {
    // logic here with $id and $name
}

支持为负的字符串偏移量
var_dump("abcdef"[-2]);

通过 Closure::fromCallable() 将callables转为闭包

新的 object 对象类型

spl_object_id()



转换对象和数组中的数字键
$obj = new class {
    public function __construct()
    {
        $this->{0} = 1;
    }
};

is_countable()
array_key_first()
array_key_last()
hrtime ( bool $get_as_number = false ) : mixed

属性添加限定类型
箭头函数 提供了一种更简洁的定义函数的方法。

<?php
$factor = 10;
$nums = array_map(fn($n) => $n * $factor, [1, 2, 3, 4]);

空合并运算符赋值
$array['key'] ??= computeDefault();
等同于
if (!isset($array['key'])) {
    $array['key'] = computeDefault();
}

数值文字分隔符
299_792_458;   // decimal


real 类型已被废弃，请使用 (float) 来替代。

在没有父类的类中使用 parent 关键词已被废弃

新增注解的功能。
新增构造器属性提升功能（在构造函数中声明类的属性）。


新增 match 表达式
$age = 23;
$result = match (true) {
    $age >= 25 => 'adult',
    $age >= 18 => 'young adult',
    default => 'kid',
};
var_dump($result); // 'young adult'

新增 Nullsafe 运算符(?->)

新增 WeakMap 类。
新增 ValueError 类。

static ("后期静态绑定"中) 可以作为返回类型：
class Test {
     public function create(): static {
          return new static();
     }
}

现在可以通过 $object::class 获取类名，返回的结果和 get_class($object) 一致。

new、instanceof 可用于任何表达式， 用法为 new (expression)(...$args) 和 $obj instanceof (expression)。

添加对一些变量语法一致性的修复，例如现在能够编写 Foo::BAR::$baz。

添加 Stringable interface， 当一个类定义 __toString() 方法后会自动实现该接口。

Trait 可以定义私有抽象方法（abstract private method）。 类必须实现 trait 定义的该方法。

可作为表达式使用 throw。 使得可以编写以下用法：

<?php
$fn = fn() => throw new Exception('Exception in arrow function');
$user = $session->user ?? throw new Exception('Must have user');

参数列表中的末尾逗号为可选。

现在允许 catch (Exception) 一个 exception 而无需捕获到变量中。



